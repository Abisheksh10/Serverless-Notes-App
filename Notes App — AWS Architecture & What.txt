Notes App — AWS Architecture & What You Deployed
Overview

A minimal, secure, full-stack notes app:

Frontend: Vite (React) + Tailwind, running locally. Dev proxy /api → API Gateway.

Auth: Amazon Cognito User Pool (email sign-up/sign-in).

API: API Gateway HTTP API with JWT authorizer (validates Cognito ID token).

Compute: AWS Lambda (Node 18, ESM), single handler for all routes.

Data: DynamoDB table Notes with keys userId (PK, string) + noteId (SK, string).

Logs/Monitoring: CloudWatch Logs for the Lambda function.

IAM: Lambda execution role with DynamoDB permissions.

API Routes (HTTP API)

GET /notes — list notes for the authenticated user (claims.sub)

POST /notes — create a note { text }

DELETE /notes/{id} — delete a note by noteId

CORS / Dev proxy

In development, Vite proxies /api/* to your API Gateway URL → avoids CORS errors.

Direct browser calls to API Gateway require correct CORS handling (either API-level CORS or OPTIONS handled by Lambda). You fixed this by:

Adding OPTIONS routes to Lambda (unauthenticated) and

Returning CORS headers from Lambda responses.

What Each Service Does (and how costs happen)

I’m not listing exact prices (they vary by region and change over time). This is a how costs accrue view so you can decide what to keep or delete.

Cognito (User Pool)

Billed primarily per Monthly Active User (MAU).

If no one signs in during a month, charges tend to be minimal, but the pool still exists.

Keeping it idle still counts as a resource you own.

API Gateway (HTTP API)

Pay-per-request.

No real “idle” cost; if not called, there’s effectively no request charge.

Lambda

Pay-per-invocation and compute time.

No invocations → essentially no Lambda runtime cost.

Still writes to CloudWatch Logs when invoked.

DynamoDB

You chose On-Demand capacity → pay per read/write request + storage for items.

If you keep the table, storage charges remain (small for tiny data).

No requests → no read/write charges.

CloudWatch Logs

Pay for log ingestion and retention.

Even if you stop invoking Lambda, existing log groups remain and may incur small retention/storage costs if set to never expire.

IAM

Roles/policies don’t incur direct charges.

Your Environment Variables (Frontend)

Stored in frontend/.env:

VITE_COGNITO_REGION=...

VITE_USER_POOL_ID=...

VITE_USER_POOL_CLIENT_ID=...

VITE_API_URL=/api (during dev, to use Vite proxy)

If you point VITE_API_URL to the real API Gateway URL (not /api), you’ll be doing cross-origin calls and CORS must be correct on the API.

Auth & Request Flow (end-to-end)

User signs in (Cognito). Amplify gets an ID token (JWT).

Frontend sends Authorization: Bearer <idToken> to API Gateway.

API Gateway JWT authorizer checks:

Issuer URL = your pool’s URL

Audience = your App client ID

If valid, request reaches Lambda.

Lambda reads userId = claims.sub, queries Notes by userId, and returns JSON.

All responses include CORS headers (for direct browser calls). In dev, proxy avoids CORS entirely.

Why you saw CORS errors (and what fixed them)

Browsers preflight if you send Authorization/application/json cross-origin.

Your API initially didn’t return Access-Control-Allow-Origin on OPTIONS.

You fixed it by:

Using Vite dev proxy (/api) — avoids browser CORS in dev.

Updating Lambda to handle OPTIONS and return CORS headers (works even without the proxy).

Ensuring OPTIONS routes are not protected by an authorizer.